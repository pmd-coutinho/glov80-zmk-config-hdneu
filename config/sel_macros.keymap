/* Macro timers; can be increased for systems that don't like 0ms Macros */
#define FAST_MACRO_TAP_MS 0
#define FAST_MACRO_WAIT_MS 0

/* How long until the word and line selection feature times out */
#define SELECT_TIMEOUT_MS 60000

/* Wrap ZMK_MACRO to avoid needing to specify Macro node */
#define ZMKMACRO(NAME, ...) \
    / { \
        macros { \
            ZMK_MACRO(NAME, __VA_ARGS__) \
        }; \
    };

/* Instant key press Macro helper using defined timers */
#define FAST_MACRO(NAME, BINDINGS) \
    ZMKMACRO(NAME, \
        tap-ms = <FAST_MACRO_TAP_MS>; \
        wait-ms = <FAST_MACRO_WAIT_MS>; \
        bindings = <BINDINGS>; \
    )

/*****************************************************************************/
                            /* Layer Conditions */
/*****************************************************************************/

/* Conditional Layer helper */
#define LAYER_CONDITION(NAME, IF, THEN) \
    NAME { \
        if-layers = <IF>; \
        then-layer = <THEN>; \
    };

/ {
    conditional_layers {
        compatible = "zmk,conditional-layers";

        /* Restrict selection continuation to Editing layer */
        LAYER_CONDITION(continue_selection, LAYER_Cursor SELECT_CONT_SL, SELECT_CONT)

        /* Layer lock feature for Editing layer */
        LAYER_CONDITION(editing_mo, EDITING_MO, LAYER_Cursor)
    };
};

/*****************************************************************************/
                /* Sticky Layer State Machine Helper C Macros */
/*****************************************************************************/

/* Generic helper for Sticky Layer state machine actions and state
   transitions. Used to build more specific helpers for features that use this
   technique. SL_BEHAVIOR argument allows different features to use distinct
   Sticky Layer implementations. Performs state transitions seamlessly even
   when rolling into other keys. */
#define STATE_TRANSITION(NAME, ENTRY, ACTION_BINDING, SL_BEHAVIOR, \
                         NEXT_STATE_LAYER) \
    FAST_MACRO(NAME, \
        ENTRY  /* Optional setup, pass &macro_tap &... */ \
        &macro_press ACTION_BINDING  /* Main action */ \
        &macro_tap SL_BEHAVIOR NEXT_STATE_LAYER  /* Move to next state */ \
        &macro_pause_for_release  /* Hold for repeating key press */ \
        &macro_release ACTION_BINDING \
    )

/* State transition macro that allows taking an action after key release, at
   the cost of not supporting rolls into the next state. */
#define STATE_TRANSITION_WITH_EXIT(NAME, ENTRY, ACTION_BINDING, EXIT, \
                                   SL_BEHAVIOR, NEXT_STATE_LAYER) \
    FAST_MACRO(NAME, \
        ENTRY  /* Optional setup, pass &macro_tap &... */ \
        &macro_press ACTION_BINDING  /* Main action */ \
        &macro_pause_for_release  /* Hold for repeating key press */ \
        &macro_release ACTION_BINDING \
        EXIT \
        &macro_tap SL_BEHAVIOR NEXT_STATE_LAYER  /* Move to next state */ \
    )

/* Sticky Layer Behavior definition helper */
#define STICKY_LAYER_HELPER(NAME, TIMEOUT_MS, ...) \
    ZMK_BEHAVIOR(NAME, \
        compatible = "zmk,behavior-sticky-key"; \
        #binding-cells = <1>; \
        release-after-ms = <TIMEOUT_MS>;  /* Release if no key is pressed */ \
        bindings = <&mo>; \
        __VA_ARGS__ \
    )

/* Quick release Sticky Layer */
#define STICKY_LAYER_QUICK_RELEASE(NAME, TIMEOUT_MS) \
    STICKY_LAYER_HELPER(NAME, TIMEOUT_MS, \
        quick-release;  /* Release as soon as another key is pressed */ \
        ignore-modifiers;  /* Mods do not release Sticky Layer */ \
    )

/* Quick release Sticky Layer that does not ignore modifiers */
#define STICKY_LAYER_NO_MODS(NAME, TIMEOUT_MS) \
    STICKY_LAYER_HELPER(NAME, TIMEOUT_MS, \
        quick-release;  /* Release as soon as another key is pressed */ \
        /delete-property/ ignore-modifiers;  /* Mods release Sticky Layer */ \
    )

/* Helper for defining Mod Morph filters for catching modifiers on a state
   Sticky Layer that does not ignore them in order to reset the state
   machine */
#define MOD_FILTER_HELPER(NAME, STANDARD, FILTERED, MODS) \
    MOD_MORPH(NAME, STANDARD, FILTERED, MODS, \
        keep-mods = <(MODS)>; \
    )

/* Filter for catching catching all mods */
#define FILTER_ALL_MODS(NAME, STANDARD, FILTERED) \
    MOD_FILTER_HELPER(NAME, STANDARD, FILTERED, \
        MOD_LSFT|MOD_RSFT|MOD_LCTL|MOD_RCTL|MOD_LALT|MOD_RALT|MOD_LGUI| \
        MOD_RGUI \
    )

/* Filter for catching all mods except Shift */
#define FILTER_NON_SHIFT_MODS(NAME, STANDARD, FILTERED) \
    MOD_FILTER_HELPER(NAME, STANDARD, FILTERED, \
        MOD_LCTL|MOD_RCTL|MOD_LALT|MOD_RALT|MOD_LGUI|MOD_RGUI \
    )

/*****************************************************************************/
                        /* Word & Line Selection */
/*****************************************************************************/

/* Quick release Sticky Layer Behavior that does not ignore modifiers using
   defined timer for continuing the word and line selection feature */
STICKY_LAYER_NO_MODS(sl_select_cont, SELECT_TIMEOUT_MS)

/* Select Macro definition helper */
#define SELECT_HELPER(NAME, SETUP, SELECTION_BINDING, CLEANUP) \
    STATE_TRANSITION_WITH_EXIT(NAME, SETUP, SELECTION_BINDING, CLEANUP, \
        &sl_select_cont, SELECT_CONT_SL)

/* Select word start Macro helper */
#define SELECT_WORD_START_MACRO(NAME, SETUP_BINDINGS, SELECTION_BINDING) \
    SELECT_HELPER(NAME, &macro_tap SETUP_BINDINGS, SELECTION_BINDING, \
        /* No CLEANUP */)

/* Select line start Macro helper */
#define SELECT_LINE_START_MACRO(NAME, SETUP_BINDINGS, SELECTION_BINDING, \
                                CLEANUP_BINDINGS) \
    SELECT_HELPER(NAME, &macro_tap SETUP_BINDINGS, SELECTION_BINDING, \
        &macro_tap CLEANUP_BINDINGS)

/* Select word continue Macro helper */
#define SELECT_WORD_CONT_MACRO(NAME, SELECTION_BINDING) \
    SELECT_HELPER(NAME, /* No SETUP */, SELECTION_BINDING, /* No CLEANUP */)

/* Select line continue Macro helper */
#define SELECT_LINE_CONT_MACRO(NAME, SELECTION_BINDING, CLEANUP_BINDINGS) \
    SELECT_HELPER(NAME, /* No SETUP */, SELECTION_BINDING, \
        &macro_tap CLEANUP_BINDINGS)

/* Movement, jumping and selection helper macros */
#define MAC_WF   LA(RIGHT)              /* Jump forward a word on Mac */
#define MAC_WB   LA(LEFT)               /* Jump backward a word on Mac */
#define MAC_HOME LG(LEFT)               /* Jump to start of line on Mac */
#define PC_WF    LC(RIGHT)              /* Jump forward a word on PC */
#define PC_WB    LC(LEFT)               /* Jump backward a word on PC */
#define PC_HOME  HOME                   /* Jump to start of line on PC */
#define SEL(MOVEMENT) &kp LS(MOVEMENT)  /* Select text */

/* Jump to start or end of word regardless of cursor position */
#define MAC_START_OF_WD &kp MAC_WF &kp MAC_WB
#define MAC_END_OF_WD &kp MAC_WB &kp MAC_WF
#define PC_START_OF_WD &kp PC_WF &kp PC_WB
#define PC_END_OF_WD &kp PC_WB &kp PC_WF

/* We use LG(LEFT) / HOME twice to avoid an issue with IDEs being too smart and
   placing the cursor after the indenting whitespace */
#define MAC_START_OF_LN &kp MAC_HOME &kp MAC_HOME
#define MAC_START_OF_NEXT_LN &kp DOWN &kp MAC_HOME &kp MAC_HOME
#define MAC_SEL_START_OF_LN SEL(MAC_HOME) SEL(MAC_HOME)
#define PC_START_OF_LN &kp PC_HOME &kp PC_HOME
#define PC_START_OF_NEXT_LN &kp DOWN &kp PC_HOME &kp PC_HOME
#define PC_SEL_START_OF_LN SEL(PC_HOME) SEL(PC_HOME)

/* Word select Macros for Mac */
SELECT_WORD_START_MACRO(sel_wd_fwd_mac, MAC_START_OF_WD, SEL(MAC_WF))
SELECT_WORD_START_MACRO(sel_wd_bwd_mac, MAC_END_OF_WD, SEL(MAC_WB))
SELECT_WORD_CONT_MACRO(cont_sel_wd_fwd_mac, SEL(MAC_WF))
SELECT_WORD_CONT_MACRO(cont_sel_wd_bwd_mac, SEL(MAC_WB))

/* Word select Macros for PC */
SELECT_WORD_START_MACRO(sel_wd_fwd_pc, PC_START_OF_WD, SEL(PC_WF))
SELECT_WORD_START_MACRO(sel_wd_bwd_pc, PC_END_OF_WD, SEL(PC_WB))
SELECT_WORD_CONT_MACRO(cont_sel_wd_fwd_pc, SEL(PC_WF))
SELECT_WORD_CONT_MACRO(cont_sel_wd_bwd_pc, SEL(PC_WB))

/* Line select Macros for Mac */
SELECT_LINE_START_MACRO(sel_ln_fwd_mac, \
    MAC_START_OF_LN, SEL(DOWN), MAC_SEL_START_OF_LN)
SELECT_LINE_START_MACRO(sel_ln_bwd_mac, \
    MAC_START_OF_NEXT_LN, SEL(UP), MAC_SEL_START_OF_LN)
SELECT_LINE_CONT_MACRO(cont_sel_ln_fwd_mac, SEL(DOWN), MAC_SEL_START_OF_LN)
SELECT_LINE_CONT_MACRO(cont_sel_ln_bwd_mac, SEL(UP), MAC_SEL_START_OF_LN)

/* Line select Macros for PC */
SELECT_LINE_START_MACRO(sel_ln_fwd_pc, \
    PC_START_OF_LN, SEL(DOWN), PC_SEL_START_OF_LN)
SELECT_LINE_START_MACRO(sel_ln_bwd_pc, \
    PC_START_OF_NEXT_LN, SEL(UP), PC_SEL_START_OF_LN)
SELECT_LINE_CONT_MACRO(cont_sel_ln_fwd_pc, SEL(DOWN), PC_SEL_START_OF_LN)
SELECT_LINE_CONT_MACRO(cont_sel_ln_bwd_pc, SEL(UP), PC_SEL_START_OF_LN)